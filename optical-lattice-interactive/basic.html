<!DOCTYPE html>
<html>
<head lang="en">
    <meta charset="UTF-8">
    <title>FBO</title>
    <style>
        head, body{
            overflow: hidden;
            top:0;
            left:0;
            margin:0;
            padding:10px 0;
            background-color: #fafafa;
        }
        .slider {
          z-index:99;
          width: 90%;
        }
        .sliderbox {
          margin: 10px 200px;
        }
        #container {
          height: 800px;
          width: 800px;
          margin: 0px auto;
          position: relative;
          padding-bottom: 10px;
        }
        .label {
          font-size: 20px;
          font-family: sans-serif;
          padding: 4px;
        }
        .slidecontainer {
          margin: 0px auto;
          width: 800px;
        }
        canvas {
          outline: 1px solid #cccccc;
          z-index:1;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div class="slidecontainer">
      <div class="sliderbox">
        <span class="label">X</span><input type="range" min="0" max="100" value="0.01" class="slider" id="sliderX">
      </div>
      <div class="sliderbox">
        <span class="label">Y</span><input type="range" min="0" max="100" value="0.01" class="slider" id="sliderY">
      </div>
      <div class="sliderbox">
        <span class="label">Z</span><input type="range" min="0" max="100" value="0.01" class="slider" id="sliderZ">
      </div>
    </div>

    <script src="vendor/three.min.js"></script>
    <script src="ShaderLoader.js"></script>
    <script src="fbo.js"></script>
    <script src="vendor/OrbitControls.js"></script>

    <script>

        var scene, camera, renderer;
        var simulationShader;
        var xFactor = 0.0;
        var yFactor = 0.0;
        var zFactor = 0.0;

        window.onload = function() {

            var sl = new ShaderLoader();
            sl.loadShaders({
                simulation_vs : "",
                simulation_fs : "",
                render_vs : "",
                render_fs : ""
            }, "./glsl/basic/", init );

        };

        function init()
        {

            var w = 800;
            var h = 800;

            //regular scene creation
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(15,w/h, 1,10000 );
            camera.position.set( 1,1,1 );
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer();
            renderer.setClearColor (0xfafafa, 1);
            renderer.setSize( w,h );
            document.getElementById("container").append( renderer.domElement );

            controls = new THREE.OrbitControls( camera, renderer.domElement );
            controls.enableDamping = true;
          	controls.dampingFactor = 0.3;
          	controls.screenSpacePanning = false;
          	controls.minDistance = 160;
          	controls.maxDistance = 180;
          	controls.maxPolarAngle = Math.PI / 2;

            var size = 11;
            var divisions = 2;

            var gridHelper1 = new THREE.GridHelper( size, divisions );
            gridHelper1.rotation.set(Math.PI/2,0,0)
            gridHelper1.position.set(0,0,-size-1)
            var gridHelper2 = new THREE.GridHelper( size, divisions );
            gridHelper2.rotation.set(0,0,0)
            gridHelper2.position.set(0,-size-1,0)
            var gridHelper3 = new THREE.GridHelper( size, divisions );
            gridHelper3.rotation.set(0,0,Math.PI/2)
            gridHelper3.position.set(-size-1,0,0)
            scene.add( gridHelper1, gridHelper2, gridHelper3 );

            var geometry = new THREE.PlaneGeometry( 24.04, 24.04, 32 );
            var material = new THREE.MeshBasicMaterial( {color: 0x202020, side: THREE.DoubleSide} );
            var plane1 = new THREE.Mesh( geometry, material );
            plane1.position.set(0,0,-12.02)
            var plane2 = new THREE.Mesh( geometry, material );
            plane2.rotation.set(0,Math.PI/2,0)
            plane2.position.set(-12.02,0,0)
            var plane3 = new THREE.Mesh( geometry, material );
            plane3.rotation.set(Math.PI/2,0,0)
            plane3.position.set(0,-12.02,0)
            scene.add( plane1, plane2, plane3 );

            //width / height of the FBO

            var width  = 216;
            var height = 216;

            //populate a Float32Array of random positions

            function initPointCloud(size) {
              var points = new Float32Array(139968);
              var steps = 17;
              var width = size;
              var spacing = width / steps;
              var index = 0;
              for (var x = -size; x <= size; x+=spacing) {
                  for (var y = -size; y <= size; y+=spacing) {
                      for (var z = -size; z <= size; z+=spacing) {
                          index += 1;
                          points[index] = x;
                          index += 1;
                          points[index] = y;
                          index+=1;
                          points[index] = z;
                      }
                  }
              }
              return points;
            }
            // var points = initPointCloud(Math.PI*3)
            var data = getRandomData( width, height, 20);
            var positions = new THREE.DataTexture( data, 216, 216, THREE.RGBFormat, THREE.FloatType );
            positions.needsUpdate = true;

            //this will be used to update the particles' positions

            simulationShader = new THREE.ShaderMaterial({

                uniforms: {
                    positions: { type: "t", value: positions },
                    xFactor: { type: "f", value: xFactor },
                    yFactor: { type: "f", value: yFactor },
                    zFactor: { type: "f", value: zFactor },
                },
                vertexShader: ShaderLoader.get( "simulation_vs" ),
                fragmentShader:  ShaderLoader.get( "simulation_fs" ),
                // transparent: true
            });

            //this will be used to represent the particles on screen
            //note that 'positions' is a texture that will be set and updated during the FBO.update() call
            var renderShader = new THREE.ShaderMaterial( {
                uniforms: {
                    original_positions: { type: "t", value: positions },
                    positions: { type: "t", value: null },
                    pointSize: { type: "f", value: 2 },
                },
                vertexShader: ShaderLoader.get( "render_vs" ),
                fragmentShader: ShaderLoader.get( "render_fs" ),
                transparent: true,
                blending: THREE.AdditiveBlending
            } );

            //init the FBO
            FBO.init( width, height, renderer, simulationShader, renderShader );
            scene.add( FBO.particles );

            //GO !
            window.addEventListener( "resize", onResize );
            onResize();
            update();

        }

        //returns an array of random 3D coordinates
        function getRandomData( width, height, size ){

            var len = width * height * 3;
            var data = new Float32Array( len );
            while( len-- )data[len] = ( Math.random() -.5 ) * size ;
            return data;
        }


        function onResize()
        {
            // var w = window.innerWidth;
            // var h = window.innerHeight;
            // renderer.setSize(w,h);
            // camera.aspect = w/h;
            // camera.updateProjectionMatrix();
        }

        //update loop
        function update()
        {
            requestAnimationFrame(update);
            controls.update();

            //update the simulation
            FBO.update();

            var sliderX = document.getElementById('sliderX').value;
            var sliderY = document.getElementById('sliderY').value;
            var sliderZ = document.getElementById('sliderZ').value;
            simulationShader.uniforms.xFactor.value = sliderX/100;
            simulationShader.uniforms.yFactor.value = sliderZ/100;
            simulationShader.uniforms.zFactor.value = sliderY/100;

            //render the particles at the new location
            renderer.render( scene, camera );

        }

    </script>

</body>
</html>
